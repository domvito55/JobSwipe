# -*- coding: utf-8 -*-
"""
File Name: jobService.py
Description: This module contains the service class for managing job business logic.
Author: MathTeixeira
Date: December 3, 2024
Version: 3.0.1
License: MIT License
Contact Information: mathteixeira55
"""
from datetime import datetime
from fastapi.encoders import jsonable_encoder
from core.database import getNoSqlConn
from core.config import noSql
from models import Job, JobUpdate
from schemas import JobInfoSchema, SkillSchema

import logging

logger = logging.getLogger("uvicorn")


class JobService:
  """
  A service class for managing job business logic.
  """
  # ----------------------------- Create
  @staticmethod
  async def createJob(collectionName: str, job: Job) -> Job:
    """
    Create a new job document.

    This method takes a Job object, properly handles the JobInfoSchema,
    and inserts the job data into the specified collection in the database.

    Args:
      collectionName (str): The name of the collection to insert the document into.
      job (Job): The job data to be inserted.

    Returns:
      Job: The created job document, or None if an error occurred.

    Raises:
      Exception: Any exception that occurs during the creation process is caught,
                 logged, and results in returning None.
    """
    try:
      job = JobService.parsing(job)
    except Exception as e:
      logger.error(f"Error parsing job: {e}")
      return Exception(f"Error parsing job: {e}")

    # convert job object to json (dict) and exclude 'id' field that will be generated by MongoDB
    job_json = jsonable_encoder(job, exclude={"id"})

    # Check if user exists
    if not getNoSqlConn().findDocumentByFilters(noSql.USERS_COLLECTION,
                                                {"id":  job_json["userId"]}):
      logger.error(f"User does not exist: {job_json['userId']}")
      raise Exception("User does not exist")

    createdJob = getNoSqlConn().insertDocument(collectionName, job_json)

    return Job.model_validate(createdJob)

  # ------------------------------ Retrieve
  # 1. ----- get all jobs
  @staticmethod
  async def getJobs(collectionName: str) -> list[Job]:
    """
    Retrieve all job documents from a specified collection.

    Args:
      collectionName (str): The name of the collection to retrieve the documents from.

    Returns:
      list[Jobs]: A list of all jobs documents in the collection.
    """
    listJobs = getNoSqlConn().findAllDocuments(collectionName)
    listJobs = [Job.model_validate(data) for data in listJobs]

    return listJobs

  # 2. ----- get job by filters
  @staticmethod
  async def getJobByFilters(collectionName: str, filters: dict) -> Job:
    """
    Retrieve a job document by a specified filters.

    Args:
      collectionName (str): The name of the collection to search in.
      filters (dict): The filters to search by.

    Returns:
      Job: The seeker document that matches the field-value pair.
    """
    job = getNoSqlConn().findDocumentByFilters(collectionName, filters)

    if job is None:
      logger.warning(f"Job not found with filters: {filters}")
      return None
    
    job = Job.model_validate(job)
    return job

  # 3. ----- get list of jobs by query
  @staticmethod
  async def getListJobByQuery(collectionName: str, query: dict) -> list[Job]:
    """
    Retrieve a list of jobs using a query.

    Args:
      collectionName (str): The name of the collection to search in.
      query (dict): The mongo query to search by.

    Returns:
      Job: The seeker document that matches the field-value pair.
    """
    listJobs = getNoSqlConn().findListDocumentsByQuery(collectionName, query)
    listJobs = [Job.model_validate(data) for data in listJobs]

    return listJobs

  # --------------------------- Update
  @staticmethod
  async def patchJob(collectionName: str, filters: dict,
                              job: JobUpdate) -> bool:
    """
    Update an existing job document by a specified filters.

    Args:
      collectionName (str): The name of the collection to update the document in.
      filters (dict): The filters to search by.
      job (Job): The updated job data.

    Returns:
      bool: True if the document was updated, False otherwise.
    """
    try:
      job = jsonable_encoder(job)
      updateResult = getNoSqlConn().setDocument(collectionName,
                                                   filters, job)
      return Job.model_validate(updateResult)
    except Exception as e:
      logger.error(f"Error updating job: {e}")
      return None

  # --------------------------- Delete
  @staticmethod
  async def deleteJob(collectionName: str, filters: dict) -> bool:
    """
    Delete a job document by a specified field and its value.

    Args:
      collectionName (str): The name of the collection to delete the document from.
      filters (dict): The filters to search by.

    Returns:
      bool: True if the document was deleted, False otherwise.
    """
    try:
      deleteResult = getNoSqlConn().deleteDocument(collectionName, filters)
      return deleteResult
    except Exception as e:
      logger.error(f"Error deleting job: {e}")
      return None

  # --------------------------- Auxiliary Methods
  @staticmethod
  def parsing(job: Job) -> Job:
    """
    Parse a job object to ensure it is properly formatted.

    Args:
      job (Job): The job object to parse.

    Returns:
      Job: The parsed job object.
    """
    # Ensure jobInfo is an instance of 'JobInfoSchema'
    if isinstance(job.jobInfo, dict):
      job.jobInfo = JobInfoSchema(**job.jobInfo)
    # Ensure 'createdDate' is a 'date' object
    if isinstance(job.createdDate, str):
      job.createdDate = datetime.strptime(job.createdDate,
                                             '%Y-%m-%d').date()
    for skill_type in ['primarySkills', 'secondarySkills']:
      skills_dict = getattr(job, skill_type, {})
      for key in ['technicalSkills', 'transferableSkills']:
        if not isinstance(skills_dict, dict):
          logger.warning(f"Job {skill_type} is not a dictionary")
          continue
        skills = skills_dict.get(key, [])
        for i, skill in enumerate(skills):
          if isinstance(skill, dict):
            skills[i] = SkillSchema(**skill)
        skills_dict[key] = skills
      setattr(job, skill_type, skills_dict)
    return job
  



